# Базы данных

**Реляционные базы данных**, или базы данных на основе SQL, изобретены в 1970 году в компании IBM, и это все еще основной тип БД. Они используют язык SQL для управления данными и выполнения запросов. Данные в реляционной базе данных организованы в соответствии со схемой — «чертежом», который описывает, как будут храниться данные.

**Нереляционные базы данных** также известны как базы данных NoSQL. В отличие от реляционных баз данных, которые хранят данные в таблицах, нереляционные базы данных не имеют общей структурированной схемы. Вместо этого данные хранятся в нетабличном формате.

Преимущество заключается в том, что вам не нужно заранее определять модель данных. Если вы работаете с наборами данных, которые не имеют четкого определения (то есть они не упорядочены и не структурированы), нереляционные базы данных это более гибкое решение, чем реляционные.

##  Отличия реляционных (SQL) и нереляционных (NoSQL) БД

| Критерий        | Реляционные БД (SQL)                     | Нереляционные БД (NoSQL)               |
|-----------------|------------------------------------------|----------------------------------------|
| **Структура**   | Таблицы с жёсткой схемой (строки и столбцы) | Документы, ключ-значение, графы, колонки |
| **Гибкость**    | Схему сложно изменить после создания     | Гибкая схема (можно добавлять поля)    |
| **Масштабируемость** | Вертикальное (увеличение мощности сервера) | Горизонтальное (добавление серверов)   |
| **Язык запросов** | SQL (структурированный язык)            | Зависит от типа БД (часто без SQL)     |
| **Примеры**     | MySQL, PostgreSQL, Oracle               | MongoDB, Redis, Cassandra, Neo4j      |

### Плюсы и минусы

Преимущества реляционных БД (плюсы):
- **Соответствие стандарту ACID**: Соответствие стандарту Atomicity, Consistency, Isolation and Durability (ACID) гарантирует согласованность (консистентность) транзакций. При сбое одной части транзакции происходит сбой всей транзакции, и база данных возвращается к предыдущей итерации.
- **Нормализация**: Нормализация уменьшает избыточность данных и повышает их целостность, поскольку позволяет эффективно организовать данные. Это снижает затраты на хранение данных.
**Точность данных**: Использование первичных и внешних ключей предотвращает дублирование записей. Это обеспечивает высокий уровень точности данных, по сравнению с другими типами баз данных.
- **Надежность**: Реляционные базы данных используют язык SQL, который является широко распространенным и признанным языком программирования.

Недостатки реляционных БД (минусы):
- **Высокая стоимость**: Создание реляционной базы данных требует больших затрат. Вам потребуется приобрести аппаратное и программное обеспечение. Также необходимо нанять технического специалиста для настройки и обслуживания системы, а это дорого, особенно для малого бизнеса.
- **Сложности с масштабированием**: Данные в реляционной базе данных хранятся в строках и столбцах, что занимает много физической памяти. Масштабирование по вертикали (добавление дополнительных ресурсов на сервер) возможно, но это также приведет к удорожанию системы.
- **Проблемы с производительностью**: Добавление большего количества данных в реляционную базу данных повышает ее сложность, что может привести к замедлению времени отклика.
- **Ограничения**: Реляционные базы данных отлично подходят для хранения структурированных данных. Но они не идеальны, если вам нужно хранить неструктурированные данные, такие как изображения и текстовые файлы.

Преимущества нереляционных БД (плюсы):

- **Масштабируемость**: Нереляционные базы данных отличаются высокой степенью масштабируемости. Вместо того чтобы «в лоб» расширять БД, жертвуя объемом хранилища, их легко масштабировать «горизонтально», добавляя дополнительные хранилища когда понадобится. Реляционные базы данных тоже можно масштабировать горизонтально, но сделать это сложнее (и дороже).
- **Гибкая структура данных**: Реляционные базы данных ограничивают тип данных, которые вы можете хранить. В нереляционных базах данных можно хранить самые разные типы данных — текст, мейлы, фотографии, видео и звук.
- **Высокоскоростная обработка данных**: При правильной настройке нереляционные БД способны обрабатывать очень большие объемы данных из различных источников. Разработчики могут быстрее получать доступ к данным.

Недостатки нереляционных БД (минусы):
- **Проблема стандартизации**: Одним из существенных недостатков нереляционных БД является отсутствие стандартизации. Не существует общего стандарта, определяющего роли и правила. Язык запросов также сильно различается для разных нереляционных БД.
- **Несоответствие ACID-принципу**: Соответствие ACID обеспечивает согласованность транзакций. Однако не все нереляционные базы данных поддерживают ACID-стандарт, что может негативно влиять на целостность данных.
- **Рост количества неиспользуемых данных**: Хотя нереляционные базы данных позволяют легко обрабатывать очень большие объемы данных, их применение может привести к появлению так называемых «темных данных» — неиспользуемых данных, которые хранят, но не извлекают из них никакой пользы. Это может привести к проблемам с качеством данных и увеличению затрат на их хранение.

##  Отличия СУБД (MySQL vs PostgreSQL)

| Характеристика       | MySQL                          | PostgreSQL                      |
|----------------------|-------------------------------|---------------------------------|
| **Лицензия**         | Открытый исходный код    | Полностью открытый исходный код  |
| **Архитектура**      | Легковесная, OLTP-оптимизированная | Модульная, расширяемая |
| **Производительность** | Высокая скорость простых запросов | Оптимизирован для сложных аналитических запросов |
| **Типы данных**      | Базовые + JSON                | JSONB, массивы, геоданные, пользовательские типы |
| **Масштабируемость** | Вертикальная + репликация чтения | Горизонтальная (Citus), логическая репликация |
| **Транзакции**       | ACID               | Расширенный ACID + уровни изоляции  |
| **Оконные функции**  | Ограниченные                  | Полноценная поддержка |
| **Администрирование**| Простая настройка             | Требует глубокой настройки |
| **Потребление ресурсов** | Низкое                     | Высокое |
| **Типичное использование** | Веб-приложения   | Аналитика, GIS, финансовые системы |
| **Поддерживаемые языки** | PHP, C/C++, Delphi, Java, Node.js, Perl, Erlang, Go, Lisp, R   | C/C++, Delphi, Java, JavaScript, Erlang, Go, Lisp, .Net, Python, R, Tcl и др.|


Хотя PostgreSQL имеет множество передовых фич и часто считается более продвинутой и сложной системой управления базами данных, чем MySQL, у нее есть свои недостатки.

К общим недостаткам PostgreSQL можно отнести следующие:

- Несмотря на свои продвинутые функции и возможности, PostgreSQL еще не достигла того же уровня популярности и широкого использования, что и MySQL. Это привело к меньшему количеству сторонних инструментов, опытных разработчиков и администраторов баз данных в экосистеме PostgreSQL.

- Из-за своих расширенных возможностей PostgreSQL может быть сложнее в настройке и управлении, чем MySQL, поэтому она больше подходит для опытных администраторов баз данных и разработчиков.

- В некоторых случаях PostgreSQL работает медленнее, чем MySQL, из-за более сложной архитектуры и функций.

- PostgreSQL потребляет больше ресурсов, чем MySQL, особенно в плане использования памяти и процессора.

- Хотя PostgreSQL поставляется с открытым исходным кодом, стоимость внедрения и обслуживания может быть высокой из-за ее расширенных возможностей и повышенных требований к ресурсам.

- PostgreSQL заново запускает еще один процесс для каждого нового клиентского подключения, что приводит к выделению значительного объема памяти, обычно около 10 МБ на соединение. Однако такая архитектура разработана для обеспечения повышенной безопасности и изоляции между различными клиентами и, как правило, считается компромиссом ради повышения производительности, надежности и масштабируемости.

- PostgreSQL разработана с учетом приоритетов расширяемости, соответствия стандартам, масштабируемости и целостности данных. Иногда данные фичи могут снижать производительность по сравнению с MySQL, особенно в обычных рабочих нагрузках, связанных с интенсивными операциями чтения. Однако важно отметить, что точное значение разницы в производительности зависит от ряда факторов, таких как размер данных, сложность запросов и используемое оборудование.

